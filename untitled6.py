# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12PIhX4wkwh6hybriP9RK24rxuOi_JB9M
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Dense, Conv1D, MaxPooling1D, Flatten, Dropout, LSTM
from tensorflow.keras.callbacks import EarlyStopping
df = pd.read_csv('/content/dataset_sdn (4).csv')
print(df)

df.shape

df.dtypes

df.head()

df.info()

df.describe()

to_drop = ['dt']
df = df.drop(to_drop, axis='columns')
df = df[df['pktrate'] !=0]

df['src'] = [int(i.split('.')[3]) for i in df['src']]
df['dst'] = [int(i.split('.')[3]) for i in df['dst']]
df['switch'] = df['switch'].astype(str)
df['src'] = df['src'].astype(str)
df['dst'] = df['dst'].astype(str)
df['port_no'] = df['port_no'].astype(str)
df['Protocol'] = df['Protocol'].astype(str)
new_df = df

df.isnull().sum()

# Fill missing values only in numeric columns
new_df.fillna(new_df.select_dtypes(include=[np.number]).mean(), inplace=True)
new_df

print(df.columns)

available_columns = [col for col in ['switch', 'src', 'Protocol', 'dst', 'port_no'] if col in df.columns]
df = pd.get_dummies(df, columns=available_columns)

X = df.drop(['label'], axis=1)
y = df['label']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=5)

scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

import joblib
joblib.dump(scaler, 'scaler.pkl')

x_train_cnn = X_train.reshape((X_train.shape[0], 1, X_train.shape[1]))
x_test_cnn = X_test.reshape((X_test.shape[0], 1, X_test.shape[1]))

cnn_model = Sequential([
    Conv1D(filters=32, kernel_size=1, activation='relu', padding='same', input_shape=(1, X_train.shape[1])),
    MaxPooling1D(pool_size=1),
    Flatten(),
    Dense(64, activation='relu'),
    Dense(1, activation='sigmoid')
])

cnn_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

early_stopping = EarlyStopping(monitor='val_loss', patience=3, restore_best_weights=True)

cnn_model.fit(x_train_cnn, y_train, epochs=10, batch_size=32,
              validation_data=(x_test_cnn, y_test), callbacks=[early_stopping])

cnn_model.save('cnn_model.keras')

try:
    x_train_lstm = X_train.reshape((X_train.shape[0], 1, X_train.shape[1]))
    x_test_lstm = X_test.reshape((X_test.shape[0], 1, X_test.shape[1]))
except Exception as e:
    print(f"Error in reshaping: {e}")

lstm_cnn_model = Sequential([
        LSTM(64, return_sequences=True, input_shape=(1, X_train.shape[1])),
        Conv1D(filters=32, kernel_size=1, activation='relu', padding='same'),
        MaxPooling1D(pool_size=1),
        Flatten(),
        Dense(64, activation='relu'),
        Dense(1, activation='sigmoid')
    ])

lstm_cnn_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

early_stopping = EarlyStopping(monitor='val_loss', patience=3, restore_best_weights=True)

lstm_cnn_model.fit(x_train_lstm, y_train, epochs=10, batch_size=32,
                       validation_data=(x_test_lstm, y_test), callbacks=[early_stopping])

lstm_cnn_model.save('lstm_cnn_model.keras')

print("Model training completed and saved successfully.")

cnn_model = load_model('cnn_model.keras')
lstm_cnn_model = load_model('lstm_cnn_model.keras')
cnn_predictions = cnn_model.predict(x_test_cnn).round()
lstm_cnn_predictions = lstm_cnn_model.predict(x_test_lstm).round()

cnn_predictions = cnn_model.predict(x_test_cnn).flatten()
cnn_predictions = np.round(cnn_predictions)

lstm_cnn_predictions = lstm_cnn_model.predict(x_test_lstm).flatten()
lstm_cnn_predictions = np.round(lstm_cnn_predictions)

y_test_binary = np.round(y_test)

def calculate_metrics(y_true, y_pred):
    accuracy = accuracy_score(y_true, y_pred)
    precision = precision_score(y_true, y_pred)
    recall = recall_score(y_true, y_pred)
    f1 = f1_score(y_true, y_pred)
    cm = confusion_matrix(y_true, y_pred)
    specificity = cm[0, 0] / (cm[0, 0] + cm[0, 1])
    return accuracy, precision, recall, f1, specificity

cnn_accuracy, cnn_precision, cnn_recall, cnn_f1, cnn_specificity = calculate_metrics(y_test, cnn_predictions)

lstm_cnn_accuracy, lstm_cnn_precision, lstm_cnn_recall, lstm_cnn_f1, lstm_cnn_specificity = calculate_metrics(y_test, lstm_cnn_predictions)

metrics = ['Accuracy', 'Precision', 'Recall', 'F1-Score', 'Specificity']
cnn_scores = [cnn_accuracy, cnn_precision, cnn_recall, cnn_f1, cnn_specificity]
lstm_cnn_scores = [lstm_cnn_accuracy, lstm_cnn_precision, lstm_cnn_recall, lstm_cnn_f1, lstm_cnn_specificity]

print("Metric Scores:")
for metric, cnn_score, lstm_cnn_score in zip(metrics, cnn_scores, lstm_cnn_scores):
    print(f"{metric}:\n  CNN: {cnn_score:.4f}\n  LSTM-CNN: {lstm_cnn_score:.4f}")

# Plot the bar chart
x = range(len(metrics))  # x-axis locations for the groups
width = 0.35  # width of the bars

# Plotting
fig, ax = plt.subplots(figsize=(10, 6))
bars1 = ax.bar(x, cnn_scores, width, label='CNN', color='b')
bars2 = ax.bar([i + width for i in x], lstm_cnn_scores, width, label='LSTM-CNN', color='g')

# Labeling
ax.set_xlabel('Metrics')
ax.set_ylabel('Scores')
ax.set_title('Comparison of CNN and LSTM-CNN Model Metrics')
ax.set_xticks([i + width / 2 for i in x])
ax.set_xticklabels(metrics)
ax.legend()

# Add value labels on top of each bar
for bars in [bars1, bars2]:
    for bar in bars:
        yval = bar.get_height()
        ax.text(bar.get_x() + bar.get_width() / 2, yval + 0.01, f"{yval:.4f}", ha='center', va='bottom')

plt.tight_layout()
plt.show()

!pip install gradio

!pip install --upgrade gradio

import pandas as pd
import numpy as np
import gradio as gr
from tensorflow.keras.models import load_model
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score

# Load dataset
df_all = pd.read_csv('/content/dataset_sdn (4).csv')
df_all_cleaned = df_all[df_all['pktrate'] != 0].copy()
df_all_cleaned.drop(['dt'], axis=1, inplace=True)

# Preprocess categorical columns
df_all_cleaned['src'] = df_all_cleaned['src'].apply(lambda x: str(int(x.split('.')[-1])))
df_all_cleaned['dst'] = df_all_cleaned['dst'].apply(lambda x: str(int(x.split('.')[-1])))
df_all_cleaned['switch'] = df_all_cleaned['switch'].astype(str)
df_all_cleaned['port_no'] = df_all_cleaned['port_no'].astype(str)
df_all_cleaned['Protocol'] = df_all_cleaned['Protocol'].astype(str)

# Fill missing values
df_all_cleaned.fillna(df_all_cleaned.select_dtypes(include=[np.number]).mean(), inplace=True)

# One-hot encoding
cat_cols = ['switch', 'src', 'Protocol', 'dst', 'port_no']
df_all_encoded = pd.get_dummies(df_all_cleaned, columns=cat_cols)

# Split features and labels
y = df_all_encoded['label']
X = df_all_encoded.drop('label', axis=1)

# Save expected column names for future alignment
expected_columns = X.columns.tolist()

# Scale features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Load trained models
cnn_model = load_model('/content/cnn_model.keras')
lstm_cnn_model = load_model('/content/lstm_cnn_model.keras')

# Reshape and predict for accuracy
X_reshaped = X_scaled.reshape(X_scaled.shape[0], 1, X_scaled.shape[1])
cnn_preds_all = cnn_model.predict(X_reshaped)
lstm_preds_all = lstm_cnn_model.predict(X_reshaped)

cnn_accuracy = accuracy_score(y, cnn_preds_all >= 0.1)
lstm_accuracy = accuracy_score(y, lstm_preds_all >= 0.5)

# Prediction function for row input
def predict_row(index):
    try:
        index = int(index)
    except:
        return "Please enter a valid number between 2 and 104346"

    if index < 2 or index > 104346:
        return f"Row {index} is out of range (2 to 104346)"

    actual_index = index - 2
    original_row = df_all.iloc[actual_index]

    if original_row['pktrate'] == 0:
        return f"Row {index} was dropped due to pktrate == 0"

    # Preprocess row
    row = original_row.drop('dt')
    row['src'] = str(int(row['src'].split('.')[-1]))
    row['dst'] = str(int(row['dst'].split('.')[-1]))
    row['switch'] = str(row['switch'])
    row['port_no'] = str(row['port_no'])
    row['Protocol'] = str(row['Protocol'])

    row_df = pd.DataFrame([row])
    row_df.fillna(df_all_cleaned.select_dtypes(include=[np.number]).mean(), inplace=True)
    row_df = pd.get_dummies(row_df, columns=cat_cols)

    # Align columns to training features
    for col in expected_columns:
        if col not in row_df.columns:
            row_df[col] = 0
    row_df = row_df[expected_columns]

    # Scale and reshape
    input_scaled = scaler.transform(row_df)
    input_reshaped = input_scaled.reshape(1, 1, input_scaled.shape[1])

    # Prediction
    cnn_pred = cnn_model.predict(input_reshaped)[0][0]
    lstm_pred = lstm_cnn_model.predict(input_reshaped)[0][0]
    true_label = int(original_row['label'])

    # Styled output
    table_md = f"""
    <h3 style="text-align: center; font-family: Arial; color: #333;"> Prediction Result for Row {index}</h3>
    <div style="font-size: 16px; font-family: Arial, sans-serif;">
        <table style="border-collapse: collapse; width: 100%;">
            <thead>
                <tr style="background-color: #f2f2f2;">
                    <th style="border: 1px solid #ddd; padding: 8px;">Metric</th>
                    <th style="border: 1px solid #ddd; padding: 8px;">Value</th>
                </tr>
            </thead>
            <tbody>
                <tr><td style="border: 1px solid #ddd; padding: 8px;">Row Index</td><td style="border: 1px solid #ddd; padding: 8px;">{index}</td></tr>
                <tr><td style="border: 1px solid #ddd; padding: 8px;">True Label</td><td style="border: 1px solid #ddd; padding: 8px;">{'Attack (1)' if true_label == 1 else 'Safe (0)'}</td></tr>
                <tr><td style="border: 1px solid #ddd; padding: 8px;">CNN Prediction</td><td style="border: 1px solid #ddd; padding: 8px;">{'Attack' if cnn_pred >= 0.5 else 'Safe'}</td></tr>
                <tr><td style="border: 1px solid #ddd; padding: 8px;">CNN Accuracy</td><td style="border: 1px solid #ddd; padding: 8px;">{cnn_accuracy:.4f}</td></tr>
                <tr><td style="border: 1px solid #ddd; padding: 8px;">LSTM-CNN Prediction</td><td style="border: 1px solid #ddd; padding: 8px;">{'Attack' if lstm_pred >= 0.5 else 'Safe'}</td></tr>
                <tr><td style="border: 1px solid #ddd; padding: 8px;">LSTM-CNN Accuracy</td><td style="border: 1px solid #ddd; padding: 8px;">{lstm_accuracy:.4f}</td></tr>
            </tbody>
        </table>
    </div>
    """
    return table_md

# Gradio Interface
with gr.Blocks() as demo:
    gr.Markdown("<h1 style='text-align: center;'><B>BOTNET DDOS DETECTION</B></h1>")
    gr.Markdown("### Enter a row index from the original dataset (2 to 104346):")
    row_input = gr.Textbox(label="Row Index", placeholder="e.g., 105")
    submit_btn = gr.Button("Submit")
    result_md = gr.HTML()

    submit_btn.click(predict_row, inputs=row_input, outputs=result_md)

# Launch the app
demo.launch(share=True, debug=False, inline=False)